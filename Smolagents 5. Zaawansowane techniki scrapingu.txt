Doskonale. Czas zaÅ‚oÅ¼yÄ‡ naszemu agentowi cyfrowÄ… pelerynÄ™-niewidkÄ™ i wyposaÅ¼yÄ‡ go w zestaw wytrychÃ³w do najtrudniejszych zamkÃ³w w internecie. Ten rozdziaÅ‚ przeniesie jego umiejÄ™tnoÅ›ci scrapingu z poziomu zaawansowanego na poziom ekspercki.

Oto kompletny, rozbudowany RozdziaÅ‚ 8, gotowy do zaimplementowania.

RozdziaÅ‚ 8: Zaawansowane Techniki Scrapingu â€“ NiewidzialnoÅ›Ä‡ i Dynamiczna TreÅ›Ä‡
Wprowadzenie
Nasz agent jest juÅ¼ inteligentny. Potrafi planowaÄ‡, korygowaÄ‡ bÅ‚Ä™dy i zapisywaÄ‡ wyniki. Jednak wspÃ³Å‚czesny internet to pole minowe dla botÃ³w. Strony internetowe, zwÅ‚aszcza te duÅ¼e, aktywnie broniÄ… siÄ™ przed automatyzacjÄ…, a ich skomplikowana, dynamiczna budowa stanowi kolejne wyzwanie.

W tym rozdziale wyposaÅ¼ymy naszego agenta w zestaw zaawansowanych technik, ktÃ³re pozwolÄ… mu dziaÅ‚aÄ‡ dyskretniej i skuteczniej na najtrudniejszych stronach. Nauczymy go cierpliwoÅ›ci w oczekiwaniu na treÅ›Ä‡, ukrywania swojej toÅ¼samoÅ›ci, zaglÄ…dania do "ukrytych Å›wiatÃ³w" w ramkach iframe oraz bezpoÅ›redniego manipulowania stronÄ… za pomocÄ… JavaScriptu. Po tym rozdziale niewiele stron bÄ™dzie w stanie mu siÄ™ oprzeÄ‡.

Krok 8.1: CierpliwoÅ›Ä‡ Agenta â€“ Jak RadziÄ‡ Sobie z DynamicznÄ… TreÅ›ciÄ…
Problem: Wiele nowoczesnych stron (tzw. Single Page Applications) nie Å‚aduje caÅ‚ej treÅ›ci od razu. Klikasz link, a treÅ›Ä‡ pojawia siÄ™ z opÃ³Åºnieniem, dociÄ…gana w tle. Nasz agent, dziaÅ‚ajÄ…c z prÄ™dkoÅ›ciÄ… maszyny, czÄ™sto prÃ³buje znaleÅºÄ‡ element, ktÃ³ry jeszcze nie zdÄ…Å¼yÅ‚ siÄ™ zaÅ‚adowaÄ‡, co prowadzi do bÅ‚Ä™du.

RozwiÄ…zanie: Musimy nauczyÄ‡ agenta czekaÄ‡. Zamiast zakÅ‚adaÄ‡, Å¼e coÅ› jest na stronie od razu, damy mu narzÄ™dzie do aktywnego oczekiwania na pojawienie siÄ™ konkretnych elementÃ³w.

Implementacja:
Dodajmy nowÄ… metodÄ™ do naszej klasy SandboxedBrowser.

Python

# TÄ˜ METODÄ˜ DODAJESZ WEWNÄ„TRZ KLASY SandboxedBrowser

async def wait_for_element(self, selector: str, timeout: int = 10) -> str:
    """
    Czeka na pojawienie siÄ™ elementu pasujÄ…cego do selektora na stronie.
    Przydatne na stronach, ktÃ³re dynamicznie Å‚adujÄ… treÅ›Ä‡.
    :param selector: Selektor CSS elementu, na ktÃ³ry naleÅ¼y czekaÄ‡.
    :param timeout: Maksymalny czas oczekiwania w sekundach.
    """
    print(f"--- NarzÄ™dzie: Czekam na element '{selector}' (max {timeout}s)... ---")
    try:
        # Konwertujemy sekundy na milisekundy dla Playwright
        timeout_ms = timeout * 1000
        element = self.page.locator(selector)
        await element.wait_for(state='visible', timeout=timeout_ms)
        return f"Element '{selector}' jest juÅ¼ widoczny na stronie."
    except Exception as e:
        return f"BÅÄ„D: Element '{selector}' nie pojawiÅ‚ siÄ™ w ciÄ…gu {timeout} sekund. PowÃ³d: {e}"
Krok 8.2: Peleryna Niewidka â€“ Rotacja User-Agent
Problem: KaÅ¼da przeglÄ…darka, Å‚Ä…czÄ…c siÄ™ ze stronÄ…, wysyÅ‚a swÃ³j "dowÃ³d osobisty" zwany User-Agent. DomyÅ›lny User-Agent Playwrighta krzyczy "JESTEM BOTEM!". Wiele systemÃ³w antybotowych blokuje takie poÅ‚Ä…czenia od razu.

RozwiÄ…zanie: BÄ™dziemy udawaÄ‡ zwykÅ‚ego uÅ¼ytkownika, losujÄ…c User-Agent prawdziwej, popularnej przeglÄ…darki przy kaÅ¼dym uruchomieniu agenta.

Implementacja:

Na poczÄ…tku pliku scraper_agent.py, zaraz po importach, dodaj listÄ™ z User-Agentami i zaimportuj bibliotekÄ™ random.

Python

import random # Dodaj ten import na gÃ³rze pliku

# ... istniejÄ…ce importy

# Lista popularnych User-AgentÃ³w do losowania
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Safari/605.1.15",
]
NastÄ™pnie, w klasie SandboxedBrowser, zmodyfikuj metodÄ™ start, aby uÅ¼ywaÅ‚a losowego User-Agenta przy tworzeniu kontekstu przeglÄ…darki.

Python

# WEWNÄ„TRZ KLASY SandboxedBrowser, ZMIEÅƒ METODÄ˜ 'start'

async def start(self):
    # ... (kod uruchamiania sandboksu i instalacji bez zmian) ...

    print("--- Inicjalizacja: Uruchamiam przeglÄ…darkÄ™ z losowym User-Agentem... ---")
    browser_args = ['--headless=new']
    if self.use_proxy:
        browser_args.append(f"--proxy-server={PROXY_CONFIG['server']}")

    self.playwright = await async_playwright().start()
    self.browser = await self.playwright.chromium.launch(headless=True, args=browser_args)

    # === TUTAJ ZACHODZI ZMIANA ===
    # Tworzymy kontekst z losowym User-Agentem
    context = await self.browser.new_context(
        user_agent=random.choice(USER_AGENTS)
    )
    # ============================

    if self.use_proxy and PROXY_CONFIG['username']:
        await context.set_http_credentials({ 'username': PROXY_CONFIG['username'], 'password': PROXY_CONFIG['password'] })

    self.page = await context.new_page()
    print("--- Inicjalizacja: Gotowy do pracy! ---")
Krok 8.3: Åšwiat w Åšwiecie â€“ Interakcja z Ramkami <iframe>
Problem: CzÄ™sto kluczowe elementy strony, takie jak formularze logowania, panele pÅ‚atnoÅ›ci, a nawet zgody na ciasteczka, sÄ… umieszczone w ramce <iframe>. To w praktyce osobna strona wewnÄ…trz strony. Nasze dotychczasowe narzÄ™dzia nie potrafiÄ… do niej zajrzeÄ‡.

RozwiÄ…zanie: Stworzymy nowe, wyspecjalizowane narzÄ™dzia, ktÃ³re najpierw "wejdÄ…" do ramki, a dopiero potem wykonajÄ… w niej akcjÄ™.

Implementacja:
Dodaj dwie nowe metody do klasy SandboxedBrowser.

Python

# TE METODY DODAJESZ WEWNÄ„TRZ KLASY SandboxedBrowser

async def click_element_in_iframe(self, iframe_selector: str, element_selector: str) -> str:
    """
    Klika w element, ktÃ³ry znajduje siÄ™ wewnÄ…trz ramki iframe.
    :param iframe_selector: Selektor CSS ramki iframe.
    :param element_selector: Selektor CSS elementu wewnÄ…trz tej ramki.
    """
    print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by kliknÄ…Ä‡ w '{element_selector}'... ---")
    try:
        # Najpierw lokalizujemy ramkÄ™, a potem szukamy elementu w jej kontekÅ›cie
        frame = self.page.frame_locator(iframe_selector)
        await frame.locator(element_selector).click(timeout=5000)
        return f"PomyÅ›lnie klikniÄ™to w element '{element_selector}' wewnÄ…trz ramki '{iframe_selector}'."
    except Exception as e:
        return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element w ramce. PowÃ³d: {e}"

async def fill_input_in_iframe(self, iframe_selector: str, element_selector: str, text: str) -> str:
    """
    WypeÅ‚nia pole tekstowe, ktÃ³re znajduje siÄ™ wewnÄ…trz ramki iframe.
    """
    print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by wypeÅ‚niÄ‡ pole '{element_selector}'... ---")
    try:
        frame = self.page.frame_locator(iframe_selector)
        await frame.locator(element_selector).fill(text)
        return f"PomyÅ›lnie wypeÅ‚niono pole '{element_selector}' w ramce."
    except Exception as e:
        return f"BÅÄ„D: Nie udaÅ‚o siÄ™ wypeÅ‚niÄ‡ pola w ramce. PowÃ³d: {e}"
Krok 8.4: Magiczna RÃ³Å¼dÅ¼ka â€“ Wykonywanie JavaScriptu
Problem: Czasami interakcja z elementem jest trudna, dane sÄ… ukryte, a selektory CSS nie wystarczajÄ…. Potrzebujemy narzÄ™dzia ostatecznego.

RozwiÄ…zanie: Damy agentowi moÅ¼liwoÅ›Ä‡ bezpoÅ›redniego wykonania dowolnego kodu JavaScript na stronie. To potÄ™Å¼ne, ale i niebezpieczne narzÄ™dzie â€“ jak magiczna rÃ³Å¼dÅ¼ka, ktÃ³ra moÅ¼e zdziaÅ‚aÄ‡ cuda lub wybuchnÄ…Ä‡ w rÄ™kach.

Implementacja:
Dodaj tÄ™ metodÄ™ do klasy SandboxedBrowser.

Python

# TÄ˜ METODÄ˜ DODAJESZ WEWNÄ„TRZ KLASY SandboxedBrowser

async def execute_javascript(self, script: str) -> str:
    """
    Wykonuje dowolny kod JavaScript na stronie i zwraca wynik.
    UÅ¼ywaj ostroÅ¼nie. Zwracany wynik musi byÄ‡ serializowalny (np. string, liczba, lista).
    PrzykÅ‚ad: 'return document.title' lub 'document.body.style.backgroundColor = "red"'.
    """
    print(f"--- NarzÄ™dzie: WykonujÄ™ skrypt JS: '{script[:50]}...' ---")
    try:
        result = await self.page.evaluate(script)
        return f"PomyÅ›lnie wykonano skrypt JS. ZwrÃ³cony wynik: {result}"
    except Exception as e:
        return f"BÅÄ„D: Wykonanie skryptu JS nie powiodÅ‚o siÄ™. PowÃ³d: {e}"
Krok 8.5: Integracja Kodu â€“ PeÅ‚na, Ulepszona Wersja Agenta
Czas poÅ‚Ä…czyÄ‡ wszystkie te elementy w caÅ‚oÅ›Ä‡. PoniÅ¼ej znajduje siÄ™ kompletna, ostateczna wersja pliku scraper_agent.py na tym etapie kursu. Zawiera wszystkie nowe narzÄ™dzia i zmodyfikowanÄ… logikÄ™.

Python

# PEÅNY, ZAKTUALIZOWANY KOD PLIKU scraper_agent.py

import os
import asyncio
import json
import random
from e2b import Sandbox
from playwright.async_api import async_playwright, Page
from twocaptcha import TwoCaptcha
from smol_agents import Agent, Planner
from bs4 import BeautifulSoup

# Lista popularnych User-AgentÃ³w do losowania
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Safari/605.1.15",
]

# Konfiguracja
E2B_API_KEY = os.getenv("E2B_API_KEY")
TWOCAPTCHA_API_KEY = os.getenv("TWOCAPTCHA_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
PROXY_CONFIG = { "server": os.getenv("PROXY_SERVER"), "username": os.getenv("PROXY_USERNAME"), "password": os.getenv("PROXY_PASSWORD") }

class SandboxedBrowser:
    def __init__(self, use_proxy: bool = False):
        self.use_proxy = use_proxy
        # ... reszta __init__ bez zmian ...
        self.sandbox: Sandbox | None = None
        self.page: Page | None = None
        self.captcha_solver = TwoCaptcha(TWOCAPTCHA_API_KEY)


    async def start(self):
        print(f"--- Inicjalizacja: Uruchamiam sandbox... ---")
        self.sandbox = await Sandbox.create(template="base", api_key=E2B_API_KEY)
        
        print("--- Inicjalizacja: InstalujÄ™ zaleÅ¼noÅ›ci... ---")
        await self.sandbox.process.start_and_wait("apt-get update && apt-get install -y libnss3 libnspr4 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 libcups2 libatspi2.0-0 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 libgbm1 libxkbcommon0 libpango-1.0-0 libcairo2 libasound2")
        await self.sandbox.process.start_and_wait("pip install playwright beautifulsoup4 && playwright install chrome")
        
        print("--- Inicjalizacja: Uruchamiam przeglÄ…darkÄ™ z losowym User-Agentem... ---")
        browser_args = ['--headless=new']
        if self.use_proxy and PROXY_CONFIG['server']:
            browser_args.append(f"--proxy-server={PROXY_CONFIG['server']}")
        
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=True, args=browser_args)
        
        context = await self.browser.new_context(user_agent=random.choice(USER_AGENTS))
        if self.use_proxy and PROXY_CONFIG['username']:
            await context.set_http_credentials({ 'username': PROXY_CONFIG['username'], 'password': PROXY_CONFIG['password'] })
        self.page = await context.new_page()
        print("--- Inicjalizacja: Gotowy do pracy! ---")

    async def close(self):
        print("--- Zamykanie: SprzÄ…tam po sobie... ---")
        if hasattr(self, 'browser') and self.browser: await self.browser.close()
        if hasattr(self, 'playwright') and self.playwright: await self.playwright.stop()
        if self.sandbox: await self.sandbox.close()
        print("--- Zamykanie: Sesja zakoÅ„czona. ---")

    # --- NarzÄ™dzia Agenta (wszystkie poprzednie + nowe) ---
    async def navigate(self, url: str) -> str:
        """Nawiguje do podanego adresu URL."""
        print(f"--- NarzÄ™dzie: NawigujÄ™ do {url} ---")
        await self.page.goto(url, wait_until='domcontentloaded')
        return f"PomyÅ›lnie przeniesiono na stronÄ™: {url}"

    async def wait_for_element(self, selector: str, timeout: int = 10) -> str:
        """Czeka, aÅ¼ element pojawi siÄ™ na stronie."""
        print(f"--- NarzÄ™dzie: Czekam na element '{selector}' (max {timeout}s)... ---")
        try:
            await self.page.locator(selector).wait_for(state='visible', timeout=timeout * 1000)
            return f"Element '{selector}' jest widoczny."
        except Exception as e:
            return f"BÅÄ„D: Element '{selector}' nie pojawiÅ‚ siÄ™ w ciÄ…gu {timeout}s."

    async def click_element(self, selector: str) -> str:
        """Klika na element na stronie uÅ¼ywajÄ…c selektora CSS."""
        print(f"--- NarzÄ™dzie: Klikam w element '{selector}' ---")
        try:
            await self.page.locator(selector).click(timeout=5000)
            return f"PomyÅ›lnie klikniÄ™to w element '{selector}'."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element '{selector}'. PowÃ³d: {str(e)}"

    async def click_element_in_iframe(self, iframe_selector: str, element_selector: str) -> str:
        """Klika w element, ktÃ³ry znajduje siÄ™ wewnÄ…trz ramki iframe."""
        print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by kliknÄ…Ä‡ w '{element_selector}'... ---")
        try:
            await self.page.frame_locator(iframe_selector).locator(element_selector).click(timeout=5000)
            return f"PomyÅ›lnie klikniÄ™to w element '{element_selector}' w ramce."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element w ramce. PowÃ³d: {str(e)}"
    
    async def fill_input(self, selector: str, text: str) -> str:
        """WypeÅ‚nia pole tekstowe na stronie."""
        print(f"--- NarzÄ™dzie: WypeÅ‚niam pole '{selector}' tekstem '{text}' ---")
        await self.page.fill(selector, text)
        return f"PomyÅ›lnie wypeÅ‚niono pole '{selector}'."

    async def fill_input_in_iframe(self, iframe_selector: str, element_selector: str, text: str) -> str:
        """WypeÅ‚nia pole tekstowe, ktÃ³re znajduje siÄ™ wewnÄ…trz ramki iframe."""
        print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by wypeÅ‚niÄ‡ pole '{element_selector}'... ---")
        try:
            await self.page.frame_locator(iframe_selector).locator(element_selector).fill(text)
            return f"PomyÅ›lnie wypeÅ‚niono pole '{element_selector}' w ramce."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ wypeÅ‚niÄ‡ pola w ramce. PowÃ³d: {str(e)}"

    async def execute_javascript(self, script: str) -> str:
        """Wykonuje dowolny kod JavaScript na stronie i zwraca wynik."""
        print(f"--- NarzÄ™dzie: WykonujÄ™ skrypt JS: '{script[:50]}...' ---")
        try:
            result = await self.page.evaluate(script)
            return f"PomyÅ›lnie wykonano skrypt JS. ZwrÃ³cony wynik: {json.dumps(result)}"
        except Exception as e:
            return f"BÅÄ„D: Wykonanie skryptu JS nie powiodÅ‚o siÄ™. PowÃ³d: {str(e)}"
    
    # ... i wszystkie pozostaÅ‚e narzÄ™dzia: get_content, save_text_to_file, download_file_from_sandbox, get_page_html, list_interactive_elements ...
    async def get_content(self) -> str:
        """Pobiera i zwraca caÅ‚Ä… treÅ›Ä‡ tekstowÄ… aktualnej strony."""
        print("--- NarzÄ™dzie: Pobieram treÅ›Ä‡ strony... ---")
        content_html = await self.page.content()
        await self.sandbox.filesystem.write("/tmp/page.html", content_html)
        script = """
from bs4 import BeautifulSoup
with open('/tmp/page.html', 'r', encoding='utf-8') as f:
    soup = BeautifulSoup(f, 'html.parser')
    for item in soup(["script", "style"]): item.extract()
    print(soup.get_text(separator=' ', strip=True))
"""
        proc = await self.sandbox.process.start_and_wait(f"python -c \"{script}\"")
        return f"Oto treÅ›Ä‡ strony: {proc.stdout}"

    async def save_text_to_file(self, filename: str, content: str) -> str:
        """Zapisuje podany tekst (content) do pliku o podanej nazwie (filename)."""
        print(f"--- NarzÄ™dzie: ZapisujÄ™ dane do pliku '{filename}'... ---")
        await self.sandbox.filesystem.write(filename, content)
        return f"PomyÅ›lnie zapisano dane w pliku '{filename}'."

    async def download_file_from_sandbox(self, filename: str) -> str:
        """Pobiera plik o podanej nazwie (filename) z sandboksu na dysk lokalny."""
        print(f"--- NarzÄ™dzie: Pobieram plik '{filename}'... ---")
        file_content_bytes = await self.sandbox.filesystem.read_bytes(filename)
        with open(filename, "wb") as f: f.write(file_content_bytes)
        return f"PomyÅ›lnie pobrano plik '{filename}'."

    async def get_page_html(self) -> str:
        """Zwraca peÅ‚ny kod HTML aktualnie otwartej strony."""
        print("--- NarzÄ™dzie: Pobieram peÅ‚ny kod HTML strony... ---")
        return await self.page.content()

    async def list_interactive_elements(self) -> str:
        """Zwraca listÄ™ wszystkich interaktywnych elementÃ³w (linkÃ³w i przyciskÃ³w)."""
        print("--- NarzÄ™dzie: ListujÄ™ wszystkie interaktywne elementy... ---")
        elements = await self.page.eval_on_selector_all("a, button", """
            (elements) => elements.filter(el => el.innerText.trim()).map(el => ({
                tag: el.tagName.toLowerCase(),
                text: el.innerText.trim(),
                selector: el.getAttribute('href') ? `a[href="${el.getAttribute('href')}"]` : `#${el.getAttribute('id')}`
            }))
        """)
        unique_elements = [dict(t) for t in {tuple(d.items()) for d in elements}]
        return f"Oto znalezione elementy interaktywne: {json.dumps(unique_elements, indent=2)}"


# PÄ™tla ReAct (bez zmian)
async def run_react_loop(agent: Agent, browser_session: SandboxedBrowser, initial_prompt: str):
    max_iterations = 15 # Dajemy trochÄ™ wiÄ™cej iteracji na zÅ‚oÅ¼one zadania
    prompt = initial_prompt
    for i in range(max_iterations):
        print(f"\n--- ğŸ¤” ITERACJA {i + 1}/{max_iterations} ---")
        try:
            response_json = await agent.planner.get_plan(prompt)
            thought = response_json.get("thought")
            action_name = response_json.get("action")
            action_params = response_json.get("params", {})
            print(f"ğŸ’¬ MyÅ›l: {thought}")
            print(f"ğŸ¬ DziaÅ‚anie: {action_name} z parametrami {action_params}")
            if action_name == "finish":
                print("\n--- âœ… ZADANIE ZAKOÅƒCZONE ---")
                print(f"Ostateczna odpowiedÅº: {action_params.get('answer', 'Brak odpowiedzi.')}")
                return
            tool_to_execute = next((t for t in agent.tools if t.__name__ == action_name), None)
            if tool_to_execute:
                observation = await tool_to_execute(**action_params)
            else:
                observation = f"BÅÄ„D: Nie znaleziono narzÄ™dzia o nazwie '{action_name}'."
            print(f"ğŸ‘€ Obserwacja: {observation[:300]}...")
            prompt += f"\nThought: {thought}\nAction: {{\"action\": \"{action_name}\", \"params\": {action_params}}}\nObservation: {observation}"
        except Exception as e:
            print(f"BÅÄ„D KRYTYCZNY W PÄ˜TLI: {e}")
            prompt += f"\nObservation: WystÄ…piÅ‚ bÅ‚Ä…d. SprÃ³buj inaczej. BÅ‚Ä…d: {e}"
    print("\n---  Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹ ---")


async def main():
    browser_session = SandboxedBrowser()
    try:
        await browser_session.start()
        
        agent = Agent(
            name="AgentSpecjalista",
            description="Super-zaawansowany agent do web scrapingu, ktÃ³ry potrafi obsÅ‚ugiwaÄ‡ dynamiczne strony, ramki iframe, rotacjÄ™ user-agent i wykonywanie JS.",
            model="gpt-4-turbo",
            tools=[
                browser_session.navigate, browser_session.wait_for_element,
                browser_session.click_element, browser_session.click_element_in_iframe,
                browser_session.fill_input, browser_session.fill_input_in_iframe,
                browser_session.execute_javascript, browser_session.get_content, 
                browser_session.save_text_to_file, browser_session.download_file_from_sandbox,
                browser_session.get_page_html, browser_session.list_interactive_elements
            ],
            api_key=OPENAI_API_KEY
        )
        
        # Nowe zadanie, ktÃ³re wymaga zaawansowanych technik
        zadanie = """
        Twoim zadaniem jest wejÅ›Ä‡ na stronÄ™ 'https://www.w3schools.com/tags/tryit.asp?filename=tryhtml_iframe'.
        Ta strona zawiera ramkÄ™ iframe. Twoim celem jest zmiana treÅ›ci wewnÄ…trz tej ramki.
        1. Poczekaj, aÅ¼ ramka iframe z selektorem '#iframeResult' bÄ™dzie widoczna.
        2. WewnÄ…trz tej ramki znajduje siÄ™ nagÅ‚Ã³wek 'h1'. UÅ¼yj JavaScript, aby zmieniÄ‡ jego treÅ›Ä‡ na 'Agent AI was here!'.
        3. Po zmianie, pobierz caÅ‚Ä… treÅ›Ä‡ tekstowÄ… z wnÄ™trza ramki iframe, aby potwierdziÄ‡, Å¼e zmiana siÄ™ udaÅ‚a.
        4. Zapisz potwierdzenie w pliku 'w3schools_report.txt'.
        5. Pobierz ten plik.
        6. ZakoÅ„cz zadanie akcjÄ… 'finish'.
        """
        print(f"\n--- Zlecenie dla Agenta: {zadanie} ---\n")
        
        await run_react_loop(agent, browser_session, zadanie)

    except Exception as e:
        print(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d gÅ‚Ã³wny: {e}")
    finally:
        await browser_session.close()

if __name__ == "__main__":
    if not all([OPENAI_API_KEY, E2B_API_KEY]):
        print("BÅÄ„D: Brak kluczy API.")
    else:
        asyncio.run(main())

Podsumowanie i Uruchomienie
UdaÅ‚o nam siÄ™ zaimplementowaÄ‡ potÄ™Å¼ny zestaw technik, ktÃ³re czyniÄ… naszego agenta prawdziwym specjalistÄ… od web scrapingu.

Co zyskaliÅ›my?

CierpliwoÅ›Ä‡: Agent nie poddaje siÄ™ na stronach, ktÃ³re wolno Å‚adujÄ… treÅ›Ä‡.
NiewidzialnoÅ›Ä‡: UdajÄ…c prawdziwÄ… przeglÄ…darkÄ™, ma wiÄ™ksze szanse na ominiÄ™cie podstawowych systemÃ³w antybotowych.
GÅ‚Ä™bszy dostÄ™p: Potrafi operowaÄ‡ na skomplikowanych stronach z ramkami iframe.
PeÅ‚nÄ… kontrolÄ™: DziÄ™ki moÅ¼liwoÅ›ci wykonywania JavaScriptu moÅ¼e poradziÄ‡ sobie z niemal kaÅ¼dym wyzwaniem.
Jak to uruchomiÄ‡?
Tak jak poprzednio, upewnij siÄ™, Å¼e masz aktywne Å›rodowisko (venv) i ustawione klucze API. NastÄ™pnie wykonaj:
python scraper_agent.py

Czego siÄ™ spodziewaÄ‡?
Obserwuj logi. Zobaczysz, jak agent najpierw nawiguje na stronÄ™, potem uÅ¼ywa narzÄ™dzia wait_for_element (chociaÅ¼ w tym przypadku ramka Å‚aduje siÄ™ szybko), a nastÄ™pnie wywoÅ‚uje execute_javascript z odpowiednim kodem. Na koniec zapisze i pobierze plik z raportem. Po zakoÅ„czeniu jego pracy w folderze projektu znajdziesz plik w3schools_report.txt z dowodem wykonania zadania.

TwÃ³j agent jest teraz gotowy na niemal wszystko, co wspÃ³Å‚czesny internet moÅ¼e mu rzuciÄ‡ pod nogi. Jedyne, co nas ogranicza, to koszt i wydajnoÅ›Ä‡ â€“ a tym zajmiemy siÄ™ w nastÄ™pnym rozdziale