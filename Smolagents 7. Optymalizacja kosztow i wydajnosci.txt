Rozdzia≈Ç 10: Optymalizacja Koszt√≥w i Wydajno≈õci ‚Äì Jak nie zbankrutowaƒá?
Wprowadzenie
Nasz agent jest jak luksusowy samoch√≥d sportowy ‚Äì niesamowicie potƒô≈ºny, inteligentny i zdolny do rzeczy, o kt√≥rych konkurencja mo≈ºe tylko pomarzyƒá. Ma jednak jednƒÖ wadƒô, typowƒÖ dla supersamochod√≥w: paliwo≈ºerno≈õƒá. Ka≈ºde zapytanie do GPT-4 Turbo i ka≈ºda nowa sesja w sandboksie E2B to realne koszty. Przy intensywnym u≈ºytkowaniu rachunki mogƒÖ szybko rosnƒÖƒá.

W tym fina≈Çowym rozdziale przeprowadzimy tuning naszego agenta. Nie odbierzemy mu mocy, ale nauczymy go z niej korzystaƒá w spos√≥b inteligentny i oszczƒôdny. Wdro≈ºymy trzy kluczowe optymalizacje:

Inteligentny dob√≥r modeli (Model Routing): Agent bƒôdzie u≈ºywa≈Ç "m√≥zgu na dw√≥ch biegach" ‚Äì taniego i szybkiego do prostych zada≈Ñ, a drogiego i potƒô≈ºnego tylko wtedy, gdy to absolutnie konieczne.
Caching wynik√≥w: Nauczymy go, by nie wykonywa≈Ç dwa razy tej samej, kosztownej pracy.
Debugowanie wizualne: Damy sobie mo≈ºliwo≈õƒá zajrzenia agentowi przez ramiƒô, aby na ≈ºywo zobaczyƒá to, co on widzi w swojej przeglƒÖdarce.
Po tym rozdziale nasz agent bƒôdzie nie tylko inteligentny, ale i wydajny ‚Äì gotowy do realnych zastosowa≈Ñ.

Krok 10.1: Inteligentny Dob√≥r Modeli (Model Routing)
Problem: GPT-4 Turbo jest genialny w z≈Ço≈ºonym planowaniu i rozumowaniu, ale u≈ºywanie go do podejmowania prostych decyzji (np. "mam dane, teraz zapiszƒô je do pliku") to jak strzelanie z armaty do komara. Ta≈Ñsze modele, jak GPT-3.5-Turbo, sƒÖ wielokrotnie ta≈Ñsze i w zupe≈Çno≈õci wystarczajƒÖ do prostszych zada≈Ñ.

RozwiƒÖzanie: Stworzymy dwa "m√≥zgi" dla naszego agenta ‚Äì "Szybki M√≥zg" (GPT-3.5) i "Mocny M√≥zg" (GPT-4). Nastƒôpnie zaimplementujemy prosty router, kt√≥ry bƒôdzie decydowa≈Ç, kt√≥rego m√≥zgu u≈ºyƒá w danej iteracji pƒôtli ReAct.

Implementacja:
Stworzymy dwa obiekty Planner i bƒôdziemy dynamicznie wybieraƒá miƒôdzy nimi w naszej pƒôtli.

Krok 10.2: Caching ‚Äì Nie R√≥b Dwa Razy Tej Samej Roboty
Problem: Uruchomienie sandboksu, instalacja pakiet√≥w i zescrapowanie strony to najd≈Çu≈ºszy i najbardziej zasobo≈ºerny element pracy agenta. Je≈õli w ramach jednego zadania agent musi wr√≥ciƒá do tej samej strony, nie ma sensu, by robi≈Ç to wszystko od nowa.

RozwiƒÖzanie: Wprowadzimy prostƒÖ pamiƒôƒá podrƒôcznƒÖ (cache) w formie s≈Çownika Pythona. Je≈õli agent poprosi o zescrapowanie adresu URL, kt√≥ry ju≈º niedawno odwiedzi≈Ç, dostanie dane z pamiƒôci, oszczƒôdzajƒÖc czas i zasoby.

Implementacja:
Zmodyfikujemy naszƒÖ klasƒô SandboxedBrowser, dodajƒÖc do niej prosty s≈Çownik do przechowywania wynik√≥w. Zmodyfikujemy te≈º narzƒôdzie get_content, aby najpierw sprawdza≈Ço pamiƒôƒá podrƒôcznƒÖ.

Krok 10.3: Debugowanie Wizualne ‚Äì Zobacz To, Co Widzi Agent
Problem: Czasami logi tekstowe to za ma≈Ço, aby zrozumieƒá, dlaczego agentowi nie uda≈Ço siƒô kliknƒÖƒá w przycisk. Mo≈ºe zas≈Çania go jakie≈õ okienko pop-up? Mo≈ºe strona ma nietypowy layout?

RozwiƒÖzanie: E2B pozwala na ≈ºywo podglƒÖdaƒá pulpit wirtualnej maszyny, na kt√≥rej pracuje agent. W≈ÇƒÖczymy tƒô opcjƒô, aby w razie potrzeby m√≥c dos≈Çownie patrzeƒá na rƒôce naszego bota.

Implementacja:
Dodamy do naszego skryptu flagƒô VISUAL_DEBUG, kt√≥ra, gdy bƒôdzie w≈ÇƒÖczona, uruchomi przeglƒÖdarkƒô w trybie graficznym (headless=False). Nastƒôpnie poinstruujemy u≈ºytkownika, jak po≈ÇƒÖczyƒá siƒô z sesjƒÖ VNC przez panel E2B.

Krok 10.4: Integracja Kodu ‚Äì Kompletny, Zoptymalizowany Agent
Czas po≈ÇƒÖczyƒá wszystkie te koncepcje. Poni≈ºej znajduje siƒô ostateczna wersja pliku scraper_agent.py z tego kursu. Zawiera ona wszystkie om√≥wione optymalizacje.

Python

# PE≈ÅNY, ZOPTYMALIZOWANY KOD PLIKU scraper_agent.py

import os
import asyncio
import json
import random
import traceback
from e2b import Sandbox
from playwright.async_api import async_playwright, Page
from twocaptcha import TwoCaptcha
from smol_agents import Agent, Planner
from bs4 import BeautifulSoup
from langfuse import Langfuse
from langfuse.callback import CallbackHandler

# === Konfiguracja ===
# OPTYMALIZACJA: Flaga do w≈ÇƒÖczania trybu wizualnego
VISUAL_DEBUG = False # Zmie≈Ñ na True, aby w≈ÇƒÖczyƒá podglƒÖd na ≈ºywo

USER_AGENTS = [ "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36" ]
E2B_API_KEY = os.getenv("E2B_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
LANGFUSE_PUBLIC_KEY = os.getenv("LANGFUSE_PUBLIC_KEY")
LANGFUSE_SECRET_KEY = os.getenv("LANGFUSE_SECRET_KEY")

class SandboxedBrowser:
    def __init__(self, use_proxy: bool = False):
        self.use_proxy = use_proxy
        self.sandbox: Sandbox | None = None
        self.page: Page | None = None
        # OPTYMALIZACJA: Inicjalizacja pamiƒôci podrƒôcznej
        self.cache = {}

    async def start(self):
        print(f"--- Inicjalizacja: Uruchamiam sandbox... ---")
        self.sandbox = await Sandbox.create(template="base", api_key=E2B_API_KEY)
        
        # ... (instalacja zale≈ºno≈õci bez zmian) ...
        await self.sandbox.process.start_and_wait("pip install playwright beautifulsoup4 && playwright install chrome")
        
        print("--- Inicjalizacja: Uruchamiam przeglƒÖdarkƒô... ---")
        # OPTYMALIZACJA: Uruchomienie w trybie graficznym lub headless
        browser_args = [] if VISUAL_DEBUG else ['--headless=new']
        
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=not VISUAL_DEBUG, args=browser_args)
        
        context = await self.browser.new_context(user_agent=random.choice(USER_AGENTS))
        self.page = await context.new_page()

        if VISUAL_DEBUG:
            print("\n" + "="*50)
            print("üëÅÔ∏è TRYB WIZUALNY W≈ÅƒÑCZONY üëÅÔ∏è")
            print("Przejd≈∫ do swojego panelu na https://e2b.dev/sandboxes")
            print("Znajd≈∫ aktywnƒÖ sesjƒô i kliknij 'Show screen', aby zobaczyƒá pracƒô agenta.")
            input("Naci≈õnij Enter, aby kontynuowaƒá...")
            print("="*50 + "\n")

        print("--- Inicjalizacja: Gotowy do pracy! ---")

    async def close(self):
        # ... (kod zamykania bez zmian) ...
        print("--- Zamykanie: SprzƒÖtam po sobie... ---")
        if hasattr(self, 'browser') and self.browser: await self.browser.close()
        if hasattr(self, 'playwright') and self.playwright: await self.playwright.stop()
        if self.sandbox: await self.sandbox.close()
        print("--- Zamykanie: Sesja zako≈Ñczona. ---")

    # OPTYMALIZACJA: Nowe, zunifikowane narzƒôdzie do scrapowania z obs≈ÇugƒÖ cache
    async def get_content_from_url(self, url: str) -> str:
        """
        Nawiguje do podanego URL i pobiera tre≈õƒá strony.
        U≈ºywa pamiƒôci podrƒôcznej, aby unikaƒá wielokrotnego pobierania tej samej strony.
        """
        print(f"--- Narzƒôdzie: Pobieram tre≈õƒá z {url} ---")
        if url in self.cache:
            print("CACHE HIT: Zwracam dane z pamiƒôci podrƒôznej.")
            return self.cache[url]
        
        print("CACHE MISS: Rozpoczynam ≈õwie≈ºe pobieranie.")
        await self.navigate(url)
        content = await self.get_content()
        self.cache[url] = content # Zapisujemy wynik w cache
        return content

    # Pozosta≈Çe narzƒôdzia, z kt√≥rych czƒô≈õƒá mo≈ºe zostaƒá uproszczona lub usuniƒôta
    # na rzecz `get_content_from_url` w bardziej zaawansowanej wersji.
    # Na potrzeby kursu zostawiamy je, aby agent mia≈Ç wyb√≥r.
    # ... (wklej tutaj wszystkie pozosta≈Çe metody-narzƒôdzia z Rozdzia≈Çu 9) ...
    async def navigate(self, url: str) -> str:
        """Nawiguje do podanego adresu URL."""
        print(f"--- Narzƒôdzie: Nawigujƒô do {url} ---")
        await self.page.goto(url, wait_until='domcontentloaded')
        return f"Pomy≈õlnie przeniesiono na stronƒô: {url}"

    async def get_content(self) -> str:
        """Pobiera i zwraca ca≈ÇƒÖ tre≈õƒá tekstowƒÖ aktualnej strony."""
        print("--- Narzƒôdzie: Pobieram tre≈õƒá strony... ---")
        content_html = await self.page.content()
        await self.sandbox.filesystem.write("/tmp/page.html", content_html)
        script = """
from bs4 import BeautifulSoup
with open('/tmp/page.html', 'r', encoding='utf-8') as f:
    soup = BeautifulSoup(f, 'html.parser')
    for item in soup(["script", "style"]): item.extract()
    print(soup.get_text(separator=' ', strip=True))
"""
        proc = await self.sandbox.process.start_and_wait(f"python -c \"{script}\"")
        return f"Oto tre≈õƒá strony: {proc.stdout}"

    async def save_text_to_file(self, filename: str, content: str) -> str:
        """Zapisuje podany tekst (content) do pliku o podanej nazwie (filename)."""
        print(f"--- Narzƒôdzie: Zapisujƒô dane do pliku '{filename}'... ---")
        await self.sandbox.filesystem.write(filename, content)
        return f"Pomy≈õlnie zapisano dane w pliku '{filename}'."

    async def download_file_from_sandbox(self, filename: str) -> str:
        """Pobiera plik o podanej nazwie (filename) z sandboksu na dysk lokalny."""
        print(f"--- Narzƒôdzie: Pobieram plik '{filename}'... ---")
        file_content_bytes = await self.sandbox.filesystem.read_bytes(filename)
        with open(filename, "wb") as f: f.write(file_content_bytes)
        return f"Pomy≈õlnie pobrano plik '{filename}'."


# Pƒôtla ReAct zintegrowana z Model Routingiem
async def run_react_loop(fast_planner: Planner, smart_planner: Planner, tools: list, initial_prompt: str, trace):
    max_iterations = 15
    prompt = initial_prompt
    
    with trace.span(name="react-loop-optimized") as span:
        for i in range(max_iterations):
            print(f"\n--- ü§î ITERACJA {i + 1}/{max_iterations} ---")
            
            try:
                # OPTYMALIZACJA: Logika routera modeli
                if "B≈ÅƒÑD" in prompt[-500:] or i < 2: # U≈ºyj mocnego modelu na poczƒÖtku lub po b≈Çƒôdzie
                    print("üß† Wybieram Mocny M√≥zg (gpt-4-turbo)...")
                    planner_to_use = smart_planner
                else:
                    print("‚ö°Ô∏è Wybieram Szybki M√≥zg (gpt-3.5-turbo)...")
                    planner_to_use = fast_planner
                
                handler = CallbackHandler(trace_id=trace.id)
                planner_to_use.callbacks = [handler]
                response_json = await planner_to_use.get_plan(prompt)
                
                thought = response_json.get("thought")
                action_name = response_json.get("action")
                action_params = response_json.get("params", {})
                
                print(f"üí¨ My≈õl: {thought}")
                print(f"üé¨ Dzia≈Çanie: {action_name} z parametrami {action_params}")
                
                if action_name == "finish":
                    print("\n--- ‚úÖ ZADANIE ZAKO≈ÉCZONE ---")
                    # ... (logika ko≈Ñcowa bez zmian) ...
                    return

                tool_to_execute = next((t for t in tools if t.__name__ == action_name), None)
                
                if tool_to_execute:
                    observation = await tool_to_execute(**action_params)
                else:
                    observation = f"B≈ÅƒÑD: Nie znaleziono narzƒôdzia o nazwie '{action_name}'."
                    
                print(f"üëÄ Obserwacja: {observation[:300]}...")
                prompt += f"\nThought: {thought}\nAction: {json.dumps({'action': action_name, 'params': action_params})}\nObservation: {observation}"

            except Exception as e:
                # ... (obs≈Çuga b≈Çƒôd√≥w bez zmian) ...
                print(f"B≈ÅƒÑD KRYTYCZNY W PƒòTLI: {e}")
                # LANGFUSE: Je≈õli wystƒÖpi b≈ÇƒÖd, oznaczamy span jako b≈Çƒôdny i zapisujemy szczeg√≥≈Çy
                error_details = traceback.format_exc()
                span.update(level='ERROR', status_message=str(e), output={"error": error_details})
                trace.update(level='ERROR')
                
                observation = f"WystƒÖpi≈Ç b≈ÇƒÖd krytyczny w pƒôtli. Spr√≥buj inaczej. B≈ÇƒÖd: {e}"
                prompt += f"\nObservation: {observation}"
                
        print("\n--- OsiƒÖgniƒôto limit iteracji ---")

async def main():
    langfuse = Langfuse(public_key=LANGFUSE_PUBLIC_KEY, secret_key=LANGFUSE_SECRET_KEY, host="https://cloud.langfuse.com")
    trace = langfuse.trace(name="optimized-agent-run", tags=["optimization-v1"])
    browser_session = SandboxedBrowser()
    try:
        await browser_session.start()
        
        agent_tools = [
            browser_session.get_content_from_url,
            # Pozosta≈Çe narzƒôdzia nadal dostƒôpne
            browser_session.save_text_to_file,
            browser_session.download_file_from_sandbox,
        ]

        # OPTYMALIZACJA: Tworzymy dwa plannery z r√≥≈ºnymi modelami
        fast_planner = Planner(model="gpt-3.5-turbo", tools=agent_tools, api_key=OPENAI_API_KEY)
        smart_planner = Planner(model="gpt-4-turbo", tools=agent_tools, api_key=OPENAI_API_KEY)
        
        # Nowe zadanie, kt√≥re testuje cache
        zadanie = """
        1. Pobierz i przeanalizuj tre≈õƒá ze strony 'http://quotes.toscrape.com/'.
        2. Nastƒôpnie pobierz tre≈õƒá ze strony 'http://quotes.toscrape.com/page/2/'.
        3. Na koniec, ponownie pobierz tre≈õƒá ze strony 'http://quotes.toscrape.com/'.
        4. Zapisz w pliku 'cache_report.txt' informacjƒô, czy trzeci krok by≈Ç szybszy.
        5. Pobierz plik 'cache_report.txt' i zako≈Ñcz zadanie.
        """
        trace.update(input=zadanie)
        print(f"\n--- Zlecenie dla Agenta: {zadanie} ---\n")
        
        await run_react_loop(fast_planner, smart_planner, agent_tools, zadanie, trace)

    except Exception as e:
        print(f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd g≈Ç√≥wny: {e}")
        trace.update(level='ERROR', status_message=str(e), output={"error": traceback.format_exc()})
    finally:
        await browser_session.close()
        langfuse.flush()
        print("--- Zako≈Ñczono dzia≈Çanie. Dane wys≈Çano do Langfuse. ---")

if __name__ == "__main__":
    if not all([OPENAI_API_KEY, E2B_API_KEY, LANGFUSE_PUBLIC_KEY, LANGFUSE_SECRET_KEY]):
        print("B≈ÅƒÑD: Brak jednego lub wiƒôcej kluczy API.")
    else:
        asyncio.run(main())
Podsumowanie i Uruchomienie
Jak to dzia≈Ça?

Model Routing: W run_react_loop zaimplementowali≈õmy prosty warunek. Na dw√≥ch pierwszych, najwa≈ºniejszych krokach (planowanie) oraz po ka≈ºdym b≈Çƒôdzie, agent u≈ºywa drogiego, ale inteligentnego smart_planner (GPT-4). Do rutynowych krok√≥w po≈õrednich u≈ºywa taniego i b≈Çyskawicznego fast_planner (GPT-3.5). Zobaczysz w logach, kt√≥ry "m√≥zg" jest aktualnie u≈ºywany.
Caching: Stworzyli≈õmy nowe, g≈Ç√≥wne narzƒôdzie get_content_from_url. Za pierwszym razem, gdy agent odwiedza stronƒô, normalnie jƒÖ scrapuje i zapisuje wynik w s≈Çowniku self.cache. Gdy w ramach zadania ma wr√≥ciƒá na tƒô samƒÖ stronƒô, narzƒôdzie natychmiast zwr√≥ci zapisany wynik, co zobaczysz w logach jako "CACHE HIT".
Debugowanie Wizualne: Zmie≈Ñ flagƒô VISUAL_DEBUG na True na samej g√≥rze pliku. Przy nastƒôpnym uruchomieniu skrypt zatrzyma siƒô i poprosi Ciƒô o naci≈õniƒôcie Enter. W tym czasie mo≈ºesz wej≈õƒá na swoje konto E2B, znale≈∫ƒá aktywnƒÖ sesjƒô i kliknƒÖƒá "Show screen". Zobaczysz na ≈ºywo pulpit z otwartƒÖ przeglƒÖdarkƒÖ i bƒôdziesz m√≥g≈Ç ≈õledziƒá ka≈ºdy ruch kursora i ka≈ºdƒÖ akcjƒô wykonywanƒÖ przez Twojego agenta.
Uruchom skrypt i obserwuj, jak agent inteligentnie zarzƒÖdza zasobami, korzystajƒÖc z pamiƒôci podrƒôcznej i prze≈ÇƒÖczajƒÖc siƒô miƒôdzy modelami.

Gratulacje! Uko≈Ñczy≈Çe≈õ pe≈Çny kurs budowy zaawansowanego agenta AI. Tw√≥j agent jest teraz nie tylko potƒô≈ºny, my≈õlƒÖcy i monitorowany, ale tak≈ºe zoptymalizowany pod kƒÖtem koszt√≥w i wydajno≈õci. Posiadasz teraz kompletny zestaw umiejƒôtno≈õci, aby budowaƒá w≈Çasne, z≈Ço≈ºone i gotowe do wdro≈ºenia aplikacje oparte na sztucznej inteligencji. ≈öwiat automatyzacji stoi przed TobƒÖ otworem!