RozdziaÅ‚ 7: Agent, ktÃ³ry MyÅ›li â€“ Planowanie, Samokorekta i PÄ™tle ReAct
Wprowadzenie
Do tej pory nasz agent, mimo swoich imponujÄ…cych zdolnoÅ›ci, dziaÅ‚aÅ‚ trochÄ™ jak robot z fabryki. OtrzymywaÅ‚ od modelu jÄ™zykowego kompletny plan dziaÅ‚ania i Å›lepo prÃ³bowaÅ‚ go wykonaÄ‡ krok po kroku. Ale co, jeÅ›li ten plan byÅ‚ oparty na bÅ‚Ä™dnych zaÅ‚oÅ¼eniach? Co, jeÅ›li strona internetowa, ktÃ³rÄ… miaÅ‚ zeskrapowaÄ‡, zmieniÅ‚a w miÄ™dzyczasie swÃ³j wyglÄ…d, a przycisk "Login" ma teraz inny identyfikator? Nasz stary agent zatrzymaÅ‚by siÄ™ i zwrÃ³ciÅ‚ bÅ‚Ä…d.

W tym rozdziale nauczymy go myÅ›leÄ‡. Zaimplementujemy architekturÄ™ ReAct, ktÃ³ra jest skrÃ³tem od Reason and Act (MyÅ›l i DziaÅ‚aj). To fundamentalna zmiana, ktÃ³ra przeksztaÅ‚ci naszego agenta w dynamicznego problem-solvera. Zamiast wykonywaÄ‡ z gÃ³ry narzucony plan, bÄ™dzie on dziaÅ‚aÅ‚ w pÄ™tli: analizowaÅ‚ sytuacjÄ™, podejmowaÅ‚ JEDEN krok, obserwowaÅ‚ jego wynik, a nastÄ™pnie na nowo analizowaÅ‚ sytuacjÄ™, by zaplanowaÄ‡ KOLEJNY krok.

Krok 7.1: Teoria w PiguÅ‚ce â€“ Czym jest PÄ™tla ReAct?
WyobraÅº sobie, Å¼e gotujesz z przepisu (stary model agenta). JeÅ›li w przepisie jest napisane "dodaj szczyptÄ™ soli", a ty nie masz soli, stoisz w miejscu.

Teraz wyobraÅº sobie, Å¼e jesteÅ› profesjonalnym kucharzem (model ReAct). TwÃ³j proces myÅ›lowy wyglÄ…da inaczej:

MyÅ›l (Reason): "Danie wydaje siÄ™ mdÅ‚e. PotrzebujÄ™ czegoÅ›, co podbije smak. SÃ³l byÅ‚aby idealna."
DziaÅ‚anie (Act): SiÄ™gasz po solniczkÄ™.
Obserwacja (Observation): "O nie, solniczka jest pusta."
MyÅ›l (Reason): "OK, plan A zawiÃ³dÅ‚. Co jeszcze mam, co jest sÅ‚one? MoÅ¼e sos sojowy? Tak, sos sojowy nada potrawie sÅ‚onoÅ›ci i dodatkowego smaku umami."
DziaÅ‚anie (Act): SiÄ™gasz po sos sojowy.
Obserwacja (Observation): "DodaÅ‚em odrobinÄ™. Danie smakuje znacznie lepiej."
Agent dziaÅ‚ajÄ…cy w pÄ™tli ReAct robi dokÅ‚adnie to samo. Zamiast prosiÄ‡ LLM o kompletne rozwiÄ…zanie, w kaÅ¼dej iteracji pÄ™tli prosimy go o wygenerowanie dwÃ³ch rzeczy: MyÅ›li (co powinienem zrobiÄ‡ teraz i dlaczego) oraz DziaÅ‚ania (jakiego narzÄ™dzia uÅ¼yÄ‡ i z jakimi argumentami). Po wykonaniu dziaÅ‚ania, jego wynik (nawet jeÅ›li to bÅ‚Ä…d!) jest ObserwacjÄ…, ktÃ³rÄ… przekazujemy z powrotem do agenta w nastÄ™pnej pÄ™tli, aby mÃ³gÅ‚ skorygowaÄ‡ swÃ³j kurs.

Krok 7.2: Nowe NarzÄ™dzia do "RozglÄ…dania SiÄ™"
Aby agent mÃ³gÅ‚ skutecznie korygowaÄ‡ bÅ‚Ä™dy, musi mieÄ‡ narzÄ™dzia, ktÃ³re pozwolÄ… mu lepiej zrozumieÄ‡ otoczenie, gdy jego pierwotne zaÅ‚oÅ¼enia zawiodÄ…. Dodamy dwie nowe, potÄ™Å¼ne metody do naszej klasy SandboxedBrowser.

OtwÃ³rz plik scraper_agent.py i dodaj poniÅ¼sze metody wewnÄ…trz klasy SandboxedBrowser.

NarzÄ™dzie 1: Czytanie surowego kodu HTML

Gdy agent nie moÅ¼e znaleÅºÄ‡ elementu po selektorze, jego pierwszÄ… myÅ›lÄ… powinno byÄ‡: "PokaÅ¼ mi kod ÅºrÃ³dÅ‚owy, sam znajdÄ™, co siÄ™ zmieniÅ‚o".

Python

# TÄ˜ METODÄ˜ DODAJESZ WEWNÄ„TRZ KLASY SandboxedBrowser

async def get_page_html(self) -> str:
    """
    Zwraca peÅ‚ny kod HTML aktualnie otwartej strony.
    UÅ¼yteczne do debugowania, gdy standardowe selektory zawodzÄ….
    """
    print("--- NarzÄ™dzie: Pobieram peÅ‚ny kod HTML strony... ---")
    return await self.page.content()
NarzÄ™dzie 2: Listowanie interaktywnych elementÃ³w

Gdy agent jest kompletnie zagubiony, moÅ¼e poprosiÄ‡ o listÄ™ "wszystkich klikalnych rzeczy", Å¼eby znaleÅºÄ‡ nowy punkt zaczepienia.

Python

# TÄ˜ METODÄ˜ RÃ“WNIEÅ» DODAJESZ WEWNÄ„TRZ KLASY SandboxedBrowser

async def list_interactive_elements(self) -> str:
    """
    Zwraca listÄ™ wszystkich interaktywnych elementÃ³w (linkÃ³w i przyciskÃ³w)
    na stronie, wraz z ich tekstem i selektorami.
    """
    print("--- NarzÄ™dzie: ListujÄ™ wszystkie interaktywne elementy... ---")
    elements = await self.page.eval_on_selector_all("a, button", """
        (elements) => elements.map(el => ({
            tag: el.tagName.toLowerCase(),
            text: el.innerText.trim(),
            selector: el.getAttribute('href') || `#${el.getAttribute('id')}`
        }))
    """)
    # Usuwamy duplikaty i puste elementy
    unique_elements = [dict(t) for t in {tuple(d.items()) for d in elements if d['text']}]
    return f"Oto znalezione elementy interaktywne: {unique_elements}"
Krok 7.3: Implementacja PÄ™tli ReAct â€“ Przebudowa Logiki GÅ‚Ã³wnej
To najwiÄ™ksza zmiana. Zamiast prostego wywoÅ‚ania agent.arun(), zbudujemy wÅ‚asnÄ… pÄ™tlÄ™, ktÃ³ra bÄ™dzie zarzÄ…dzaÄ‡ caÅ‚ym procesem rozumowania i dziaÅ‚ania. BÄ™dziemy potrzebowaÄ‡ do tego trochÄ™ bardziej zaawansowanej interakcji z bibliotekÄ… Smol Agents, w szczegÃ³lnoÅ›ci z jej modelem Planner.

PoniÅ¼ej znajduje siÄ™ kompletny, zaktualizowany kod pliku scraper_agent.py. ZwrÃ³Ä‡ szczegÃ³lnÄ… uwagÄ™ na nowÄ… funkcjÄ™ run_react_loop oraz zmiany w funkcji main.

Python

# PEÅNY, ZAKTUALIZOWANY KOD PLIKU scraper_agent.py

import os
import asyncio
import json
from e2b import Sandbox
from playwright.async_api import async_playwright, Page
from twocaptcha import TwoCaptcha
from smol_agents import Agent, Planner
from bs4 import BeautifulSoup

# === KROK 1: Konfiguracja (bez zmian) ===
E2B_API_KEY = os.getenv("E2B_API_KEY")
TWOCAPTCHA_API_KEY = os.getenv("TWOCAPTCHA_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

PROXY_CONFIG = {
    "server": os.getenv("PROXY_SERVER", "http://twoj_host_proxy:port"),
    "username": os.getenv("PROXY_USERNAME", "twoj_uzytkownik"),
    "password": os.getenv("PROXY_PASSWORD", "twoje_haslo_proxy")
}

# === KROK 2: Klasa ZarzÄ…dzajÄ…ca (z nowymi narzÄ™dziami) ===
class SandboxedBrowser:
    def __init__(self, use_proxy: bool = False):
        self.sandbox: Sandbox | None = None
        self.page: Page | None = None
        self.use_proxy = use_proxy
        self.captcha_solver = TwoCaptcha(TWOCAPTCHA_API_KEY)

    async def start(self):
        print(f"--- Inicjalizacja: Uruchamiam sandbox... ---")
        self.sandbox = await Sandbox.create(template="base", api_key=E2B_API_KEY)
        
        print("--- Inicjalizacja: InstalujÄ™ zaleÅ¼noÅ›ci... ---")
        await self.sandbox.process.start_and_wait(
            "apt-get update && apt-get install -y libnss3 libnspr4 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 libcups2 libatspi2.0-0 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 libgbm1 libxkbcommon0 libpango-1.0-0 libcairo2 libasound2"
        )
        await self.sandbox.process.start_and_wait("pip install playwright beautifulsoup4 && playwright install chrome")
        
        print("--- Inicjalizacja: Uruchamiam przeglÄ…darkÄ™... ---")
        browser_args = ['--headless=new']
        if self.use_proxy:
            browser_args.append(f"--proxy-server={PROXY_CONFIG['server']}")
        
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=True, args=browser_args)
        
        context = await self.browser.new_context()
        if self.use_proxy and PROXY_CONFIG['username']:
            await context.set_http_credentials({ 'username': PROXY_CONFIG['username'], 'password': PROXY_CONFIG['password'] })

        self.page = await context.new_page()
        print("--- Inicjalizacja: Gotowy do pracy! ---")

    async def close(self):
        print("--- Zamykanie: SprzÄ…tam po sobie... ---")
        if hasattr(self, 'browser') and self.browser: await self.browser.close()
        if hasattr(self, 'playwright') and self.playwright: await self.playwright.stop()
        if self.sandbox: await self.sandbox.close()
        print("--- Zamykanie: Sesja zakoÅ„czona. ---")

    # --- NarzÄ™dzia Agenta ---
    async def navigate(self, url: str) -> str:
        """Nawiguje do podanego adresu URL."""
        print(f"--- NarzÄ™dzie: NawigujÄ™ do {url} ---")
        await self.page.goto(url, wait_until='domcontentloaded')
        return f"PomyÅ›lnie przeniesiono na stronÄ™: {url}"

    async def click_element(self, selector: str) -> str:
        """Klika na element na stronie uÅ¼ywajÄ…c selektora CSS."""
        print(f"--- NarzÄ™dzie: Klikam w element '{selector}' ---")
        try:
            await self.page.click(selector, timeout=5000)
            return f"PomyÅ›lnie klikniÄ™to w element '{selector}'."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element '{selector}'. PowÃ³d: {e}"

    async def fill_input(self, selector: str, text: str) -> str:
        """WypeÅ‚nia pole tekstowe na stronie."""
        print(f"--- NarzÄ™dzie: WypeÅ‚niam pole '{selector}' tekstem '{text}' ---")
        await self.page.fill(selector, text)
        return f"PomyÅ›lnie wypeÅ‚niono pole '{selector}'."

    async def get_content(self) -> str:
        """Pobiera i zwraca caÅ‚Ä… treÅ›Ä‡ tekstowÄ… aktualnej strony."""
        print("--- NarzÄ™dzie: Pobieram treÅ›Ä‡ strony... ---")
        content_html = await self.page.content()
        await self.sandbox.filesystem.write("/tmp/page.html", content_html)
        script = """
from bs4 import BeautifulSoup
with open('/tmp/page.html', 'r', encoding='utf-8') as f:
    soup = BeautifulSoup(f, 'html.parser')
    for item in soup(["script", "style"]): item.extract()
    print(soup.get_text(separator=' ', strip=True))
"""
        proc = await self.sandbox.process.start_and_wait(f"python -c \"{script}\"")
        return f"Oto treÅ›Ä‡ strony: {proc.stdout}"

    async def save_text_to_file(self, filename: str, content: str) -> str:
        """Zapisuje podany tekst (content) do pliku o podanej nazwie (filename)."""
        print(f"--- NarzÄ™dzie: ZapisujÄ™ dane do pliku '{filename}'... ---")
        await self.sandbox.filesystem.write(filename, content)
        return f"PomyÅ›lnie zapisano dane w pliku '{filename}'."

    async def download_file_from_sandbox(self, filename: str) -> str:
        """Pobiera plik o podanej nazwie (filename) z sandboksu na dysk lokalny."""
        print(f"--- NarzÄ™dzie: Pobieram plik '{filename}'... ---")
        file_content_bytes = await self.sandbox.filesystem.read_bytes(filename)
        with open(filename, "wb") as f: f.write(file_content_bytes)
        return f"PomyÅ›lnie pobrano plik '{filename}'."

    # NOWE NARZÄ˜DZIA DODANE W TYM ROZDZIALE
    async def get_page_html(self) -> str:
        """Zwraca peÅ‚ny kod HTML aktualnie otwartej strony."""
        print("--- NarzÄ™dzie: Pobieram peÅ‚ny kod HTML strony... ---")
        return await self.page.content()

    async def list_interactive_elements(self) -> str:
        """Zwraca listÄ™ wszystkich interaktywnych elementÃ³w (linkÃ³w i przyciskÃ³w)."""
        print("--- NarzÄ™dzie: ListujÄ™ wszystkie interaktywne elementy... ---")
        elements = await self.page.eval_on_selector_all("a, button", """
            (elements) => elements.filter(el => el.innerText.trim()).map(el => ({
                tag: el.tagName.toLowerCase(),
                text: el.innerText.trim(),
                selector: el.getAttribute('href') ? `a[href="${el.getAttribute('href')}"]` : `#${el.getAttribute('id')}`
            }))
        """)
        unique_elements = [dict(t) for t in {tuple(d.items()) for d in elements}]
        return f"Oto znalezione elementy interaktywne: {json.dumps(unique_elements, indent=2)}"


# === KROK 3: PÄ™tla ReAct ===
async def run_react_loop(agent: Agent, browser_session: SandboxedBrowser, initial_prompt: str):
    """GÅ‚Ã³wna pÄ™tla ReAct, ktÃ³ra zarzÄ…dza pracÄ… agenta."""
    max_iterations = 10
    prompt = initial_prompt

    for i in range(max_iterations):
        print(f"\n--- ğŸ¤” ITERACJA {i + 1}/{max_iterations} ---")
        
        # 1. MYÅšL I DZIAÅANIE (Reason & Act)
        # Prosimy LLM o wygenerowanie planu w postaci MyÅ›li i DziaÅ‚ania
        response_json = await agent.planner.get_plan(prompt)
        
        try:
            thought = response_json.get("thought")
            action_name = response_json.get("action")
            action_params = response_json.get("params", {})
            
            print(f"ğŸ’¬ MyÅ›l: {thought}")
            print(f"ğŸ¬ DziaÅ‚anie: {action_name} z parametrami {action_params}")
            
            # Specjalny warunek koÅ„cowy
            if action_name == "finish":
                print("\n--- âœ… ZADANIE ZAKOÅƒCZONE ---")
                print(f"Ostateczna odpowiedÅº: {action_params.get('answer', 'Brak odpowiedzi.')}")
                return
            
            # 2. OBSERWACJA (Observation)
            # Znajdujemy i wykonujemy odpowiednie narzÄ™dzie
            tool_to_execute = next((t for t in agent.tools if t.__name__ == action_name), None)
            
            if tool_to_execute:
                observation = await tool_to_execute(**action_params)
            else:
                observation = f"BÅÄ„D: Nie znaleziono narzÄ™dzia o nazwie '{action_name}'."
                
            print(f"ğŸ‘€ Obserwacja: {observation[:300]}...") # Drukujemy tylko fragment dÅ‚ugich obserwacji
            
            # 3. AKTUALIZACJA PROMPTU
            # Przygotowujemy nowy prompt dla kolejnej iteracji, dodajÄ…c wynik ostatniego dziaÅ‚ania
            prompt += f"\nThought: {thought}\nAction: {{\"action\": \"{action_name}\", \"params\": {action_params}}}\nObservation: {observation}"

        except Exception as e:
            print(f"BÅÄ„D KRYTYCZNY W PÄ˜TLI: {e}")
            prompt += f"\nObservation: WystÄ…piÅ‚ bÅ‚Ä…d w pÄ™tli. SprÃ³buj inaczej. BÅ‚Ä…d: {e}"

    print("\n---  osiÄ…gniÄ™to limit iteracji ---")

# === KROK 4: GÅ‚Ã³wny Dyrygent ===
async def main():
    browser_session = SandboxedBrowser(use_proxy=False)
    try:
        await browser_session.start()
        
        # Agent jest teraz zdefiniowany bez narzÄ™dzia 'finish', poniewaÅ¼ jest ono obsÅ‚ugiwane w pÄ™tli
        agent = Agent(
            name="AgentMyÅ›liciel",
            description="Zaawansowany agent, ktÃ³ry potrafi dynamicznie planowaÄ‡ i korygowaÄ‡ swoje dziaÅ‚ania w celu wykonania zÅ‚oÅ¼onych zadaÅ„ w przeglÄ…darce.",
            model="gpt-4-turbo",
            tools=[
                browser_session.navigate, browser_session.click_element,
                browser_session.fill_input, browser_session.get_content,
                browser_session.save_text_to_file, browser_session.download_file_from_sandbox,
                browser_session.get_page_html, browser_session.list_interactive_elements
            ],
            api_key=OPENAI_API_KEY
        )
        
        # Nowe, bardziej zÅ‚oÅ¼one zadanie, ktÃ³re symuluje bÅ‚Ä…d
        zadanie = """
        Twoim celem jest znalezienie wszystkich cytatÃ³w autorstwa 'J.K. Rowling' na stronie 'http://quotes.toscrape.com/'.
        JednakÅ¼e, programista popeÅ‚niÅ‚ bÅ‚Ä…d i przycisk do przejÅ›cia na nastÄ™pnÄ… stronÄ™ nie ma selektora '#next_button', jak moÅ¼na by siÄ™ spodziewaÄ‡.
        Twoim zadaniem jest wejÅ›Ä‡ na stronÄ™, sprÃ³bowaÄ‡ kliknÄ…Ä‡ nieistniejÄ…cy przycisk, zdiagnozowaÄ‡ problem, znaleÅºÄ‡ poprawny sposÃ³b nawigacji
        (np. klikajÄ…c w link z tekstem 'Next â†’') i kontynuowaÄ‡ scraping, aÅ¼ znajdziesz cytaty lub sprawdzisz wszystkie strony.
        Na koniec, zapisz znalezione cytaty do pliku 'rowling.txt' i pobierz go. JeÅ›li nie znajdziesz Å¼adnych cytatÃ³w, poinformuj o tym w pliku.
        ZakoÅ„cz zadanie wywoÅ‚ujÄ…c akcjÄ™ 'finish' z ostatecznÄ… odpowiedziÄ….
        """
        print(f"\n--- Zlecenie dla Agenta: {zadanie} ---\n")
        
        await run_react_loop(agent, browser_session, zadanie)

    except Exception as e:
        print(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d gÅ‚Ã³wny: {e}")
    finally:
        await browser_session.close()

if __name__ == "__main__":
    if not all([OPENAI_API_KEY, E2B_API_KEY]):
        print("BÅÄ„D: Brak kluczy API. Ustaw je jako zmienne Å›rodowiskowe!")
    else:
        asyncio.run(main())
OmÃ³wienie Kluczowych Zmian
Nowe NarzÄ™dzia Diagnostyczne: get_page_html i list_interactive_elements dajÄ… agentowi "oczy i uszy" do zbadania otoczenia, gdy jego plan zawiedzie. ZwrÃ³Ä‡ uwagÄ™, Å¼e w list_interactive_elements staramy siÄ™ od razu budowaÄ‡ uÅ¼yteczne selektory, co uÅ‚atwi agentowi pracÄ™.
Nowa funkcja run_react_loop: To jest serce naszego nowego agenta. To ona, a nie biblioteka, zarzÄ…dza teraz cyklem Å¼ycia zadania.
agent.planner.get_plan(prompt): Zamiast agent.arun(), uÅ¼ywamy teraz niskopoziomowego dostÄ™pu do plannera agenta, aby uzyskaÄ‡ tylko JEDEN nastÄ™pny krok (myÅ›l i dziaÅ‚anie).
PÄ™tla for: Ogranicza maksymalnÄ… liczbÄ™ krokÃ³w, aby agent nie wpadÅ‚ w nieskoÅ„czonÄ… pÄ™tlÄ™ i nie nabiÅ‚ nam rachunku za API.
ObsÅ‚uga finish: DodaliÅ›my specjalne dziaÅ‚anie finish, ktÃ³re agent musi wywoÅ‚aÄ‡, aby poprawnie zakoÅ„czyÄ‡ zadanie. Daje nam to kontrolÄ™ nad tym, kiedy praca jest uznana za skoÅ„czonÄ….
Aktualizacja prompt: To najwaÅ¼niejsza czÄ™Å›Ä‡ pÄ™tli. Po kaÅ¼dej akcji doklejamy do oryginalnego promptu historiÄ™ (MyÅ›l, DziaÅ‚anie, Obserwacja). DziÄ™ki temu w kolejnej iteracji LLM ma peÅ‚en kontekst tego, co wÅ‚aÅ›nie siÄ™ wydarzyÅ‚o i moÅ¼e podjÄ…Ä‡ Å›wiadomÄ… decyzjÄ™.
Nowe Zadanie w main: Zadanie jest teraz znacznie bardziej opisowe. Symulujemy w nim problem (nieistniejÄ…cy selektor) i wprost instruujemy agenta, Å¼e jego zadaniem jest zdiagnozowanie i poradzenie sobie z tÄ… sytuacjÄ…. To uczy go elastycznoÅ›ci.
Uruchomienie i Obserwacja MyÅ›lenia
Uruchom skrypt tak jak poprzednio:
python scraper_agent.py

Tym razem obserwuj uwaÅ¼nie logi w terminalu. Zobaczysz wyraÅºny cykl:

ITERACJA 1: Agent pomyÅ›li: "Ok, muszÄ™ wejÅ›Ä‡ na stronÄ™" i wykona Maps.
ITERACJA 2: PomyÅ›li: "Teraz muszÄ™ znaleÅºÄ‡ przycisk 'Next'. SprÃ³bujÄ™ #next_button" i wykona click_element('#next_button').
Obserwacja bÄ™dzie brzmiaÅ‚a: "BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡...".
ITERACJA 3: Agent otrzyma tÄ™ obserwacjÄ™ i pomyÅ›li: "Aha, ten selektor nie dziaÅ‚a. MuszÄ™ zbadaÄ‡ stronÄ™. UÅ¼yjÄ™ list_interactive_elements".
Obserwacja z tego narzÄ™dzia pokaÅ¼e mu listÄ™ linkÃ³w, w tym ten z tekstem "Next â†’".
ITERACJA 4: Agent pomyÅ›li: "OK, poprawny link to ten z tekstem 'Next â†’'. Klikam w niego" i wykona click_element z poprawnym selektorem.
To jest wÅ‚aÅ›nie samokorekta w dziaÅ‚aniu!

Gratulacje! TwÃ³j agent przestaÅ‚ byÄ‡ tylko wykonawcÄ…. StaÅ‚ siÄ™ myÅ›licielem, ktÃ³ry potrafi adaptowaÄ‡ siÄ™ do zmieniajÄ…cego siÄ™ Å›rodowiska â€“ a to jest krok milowy na drodze do prawdziwie autonomicznej sztucznej inteligencji.