RozdziaÅ‚ 9: Agent pod Mikroskopem â€“ Monitorowanie i ObsÅ‚uga BÅ‚Ä™dÃ³w z Langfuse
Wprowadzenie
WyobraÅº sobie, Å¼e zbudowaÅ‚eÅ› najnowoczeÅ›niejszy samolot. Jest szybki, zwinny i potÄ™Å¼ny. Ale nie ma w nim Å¼adnych wskaÅºnikÃ³w â€“ ani wysokoÅ›ciomierza, ani wskaÅºnika paliwa, ani radaru. Czy odwaÅ¼yÅ‚byÅ› siÄ™ nim polecieÄ‡? Prawdopodobnie nie.

Do tej pory nasz agent byÅ‚ wÅ‚aÅ›nie takim samolotem. DziaÅ‚aÅ‚ imponujÄ…co, ale w duÅ¼ej mierze w "ciemno". Kiedy coÅ› szÅ‚o nie tak, dostawaliÅ›my tylko ogÃ³lny komunikat o bÅ‚Ä™dzie. Nie wiedzieliÅ›my, co dokÅ‚adnie "pomyÅ›laÅ‚", dlaczego podjÄ…Å‚ zÅ‚Ä… decyzjÄ™, ile kosztowaÅ‚a nas dana operacja, ani gdzie leÅ¼aÅ‚ prawdziwy powÃ³d awarii.

W tym rozdziale zamontujemy w naszym agencie peÅ‚nÄ… deskÄ™ rozdzielczÄ…. Zintegrujemy go z Langfuse â€“ profesjonalnÄ… platformÄ… do monitorowania aplikacji opartych na LLM. DziÄ™ki temu zyskamy wglÄ…d w kaÅ¼dÄ… jego myÅ›l, dziaÅ‚anie i obserwacjÄ™. Ulepszymy takÅ¼e naszÄ… logikÄ™, aby nie tylko lepiej radziÅ‚a sobie z bÅ‚Ä™dami, ale takÅ¼e precyzyjnie je dla nas oznaczaÅ‚.

Krok 9.1: Czym jest Langfuse i dlaczego go potrzebujemy?
Langfuse to platforma open-source stworzona specjalnie do monitorowania, debugowania i analizy aplikacji, ktÃ³rych sercem jest model jÄ™zykowy. To nasze centrum dowodzenia, ktÃ³re zbiera i w piÄ™kny, czytelny sposÃ³b wizualizuje wszystko, co dzieje siÄ™ "pod maskÄ…" agenta.

Kluczowe korzyÅ›ci:

ObserwowalnoÅ›Ä‡ (Observability): Zobaczysz dokÅ‚adnÄ… sekwencjÄ™: MyÅ›l -> DziaÅ‚anie -> Obserwacja. Koniec ze zgadywaniem, co agent prÃ³bowaÅ‚ zrobiÄ‡.
Precyzyjne Debugowanie (Debugging): Gdy zadanie siÄ™ nie powiedzie, Langfuse pokaÅ¼e Ci dokÅ‚adny krok, w ktÃ³rym wystÄ…piÅ‚ bÅ‚Ä…d, jaki byÅ‚ jego powÃ³d i jaki byÅ‚ stan agenta tuÅ¼ przed awariÄ….
Analiza KosztÃ³w (Cost Analysis): KaÅ¼de zapytanie do GPT-4 kosztuje. Langfuse automatycznie Å›ledzi zuÅ¼ycie tokenÃ³w i pokazuje koszt kaÅ¼dej operacji i caÅ‚ego zadania co do centa.
Åšledzenie WydajnoÅ›ci (Performance Tracking): Zmierzysz, ile czasu zajmuje agentowi podjÄ™cie decyzji i wykonanie zadania, co pozwoli Ci identyfikowaÄ‡ wÄ…skie gardÅ‚a.
Krok 9.2: Praktyczna Integracja z Langfuse
Czas podÅ‚Ä…czyÄ‡ naszego agenta do nowej deski rozdzielczej.

Krok 9.2.1: Instalacja
W terminalu, z aktywnym Å›rodowiskiem (venv), zainstaluj bibliotekÄ™ Langfuse:

Bash

pip install langfuse
Krok 9.2.2: Zdobycie Kluczy Langfuse
PrzejdÅº na stronÄ™ cloud.langfuse.com i zaÅ‚Ã³Å¼ darmowe konto.
Po zalogowaniu stwÃ³rz nowy projekt, np. o nazwie agent-scraper.
PrzejdÅº do sekcji "Project Settings" -> "API Keys".
Znajdziesz tam dwa klucze, ktÃ³rych potrzebujesz: Public Key (zaczyna siÄ™ od pk-lf-...) i Secret Key (zaczyna siÄ™ od sk-lf-...).
Krok 9.2.3: Konfiguracja Kluczy w Kodzie
Podobnie jak w przypadku innych kluczy, ustawimy je jako zmienne Å›rodowiskowe w terminalu przed uruchomieniem skryptu:

Na Windows (w PowerShell):
PowerShell

$env:LANGFUSE_PUBLIC_KEY = "pk-lf-..."
$env:LANGFUSE_SECRET_KEY = "sk-lf-..."
Na macOS / Linux:
Bash

export LANGFUSE_PUBLIC_KEY="pk-lf-..."
export LANGFUSE_SECRET_KEY="sk-lf-..."
NastÄ™pnie dodamy ich wczytywanie na poczÄ…tku pliku scraper_agent.py.

Krok 9.3: Ulepszona ObsÅ‚uga BÅ‚Ä™dÃ³w i PeÅ‚ny Kod z Monitorowaniem
Teraz dokonamy kluczowych zmian w naszym kodzie. Zintegrujemy klienta Langfuse, stworzymy system Å›ledzenia (trace) dla kaÅ¼dego zadania i ulepszymy pÄ™tlÄ™ ReAct, aby raportowaÅ‚a bÅ‚Ä™dy.

PoniÅ¼ej znajduje siÄ™ kompletna, ostateczna wersja pliku scraper_agent.py. ZwrÃ³Ä‡ szczegÃ³lnÄ… uwagÄ™ na sekcje oznaczone komentarzem # LANGFUSE.

Python

# PEÅNY, ZAKTUALIZOWANY KOD PLIKU scraper_agent.py

import os
import asyncio
import json
import random
import traceback
from e2b import Sandbox
from playwright.async_api import async_playwright, Page
from twocaptcha import TwoCaptcha
from smol_agents import Agent, Planner
from bs4 import BeautifulSoup

# LANGFUSE: Importy
from langfuse import Langfuse
from langfuse.callback import CallbackHandler

# Konfiguracja
USER_AGENTS = [ "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36" ]
E2B_API_KEY = os.getenv("E2B_API_KEY")
TWOCAPTCHA_API_KEY = os.getenv("TWOCAPTCHA_API_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# LANGFUSE: Wczytywanie kluczy
LANGFUSE_PUBLIC_KEY = os.getenv("LANGFUSE_PUBLIC_KEY")
LANGFUSE_SECRET_KEY = os.getenv("LANGFUSE_SECRET_KEY")

# Klasa SandboxedBrowser (bez zmian w stosunku do RozdziaÅ‚u 8)
class SandboxedBrowser:
    # ... wklej tutaj caÅ‚Ä…, nienaruszonÄ… klasÄ™ SandboxedBrowser z poprzedniego rozdziaÅ‚u ...
    # ... (dla zwiÄ™zÅ‚oÅ›ci pomijamy jej kod tutaj, ale musi on byÄ‡ w Twoim pliku) ...
    def __init__(self, use_proxy: bool = False):
        self.use_proxy = use_proxy
        self.sandbox: Sandbox | None = None
        self.page: Page | None = None
        self.captcha_solver = TwoCaptcha(TWOCAPTCHA_API_KEY)


    async def start(self):
        print(f"--- Inicjalizacja: Uruchamiam sandbox... ---")
        self.sandbox = await Sandbox.create(template="base", api_key=E2B_API_KEY)
        
        print("--- Inicjalizacja: InstalujÄ™ zaleÅ¼noÅ›ci... ---")
        await self.sandbox.process.start_and_wait("apt-get update && apt-get install -y libnss3 libnspr4 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 libcups2 libatspi2.0-0 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 libgbm1 libxkbcommon0 libpango-1.0-0 libcairo2 libasound2")
        await self.sandbox.process.start_and_wait("pip install playwright beautifulsoup4 && playwright install chrome")
        
        print("--- Inicjalizacja: Uruchamiam przeglÄ…darkÄ™ z losowym User-Agentem... ---")
        browser_args = ['--headless=new']
        # if self.use_proxy and PROXY_CONFIG['server']:
        #     browser_args.append(f"--proxy-server={PROXY_CONFIG['server']}")
        
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=True, args=browser_args)
        
        context = await self.browser.new_context(user_agent=random.choice(USER_AGENTS))
        # if self.use_proxy and PROXY_CONFIG['username']:
        #     await context.set_http_credentials({ 'username': PROXY_CONFIG['username'], 'password': PROXY_CONFIG['password'] })
        self.page = await context.new_page()
        print("--- Inicjalizacja: Gotowy do pracy! ---")

    async def close(self):
        print("--- Zamykanie: SprzÄ…tam po sobie... ---")
        if hasattr(self, 'browser') and self.browser: await self.browser.close()
        if hasattr(self, 'playwright') and self.playwright: await self.playwright.stop()
        if self.sandbox: await self.sandbox.close()
        print("--- Zamykanie: Sesja zakoÅ„czona. ---")

    # --- NarzÄ™dzia Agenta (wszystkie poprzednie + nowe) ---
    async def navigate(self, url: str) -> str:
        """Nawiguje do podanego adresu URL."""
        print(f"--- NarzÄ™dzie: NawigujÄ™ do {url} ---")
        await self.page.goto(url, wait_until='domcontentloaded')
        return f"PomyÅ›lnie przeniesiono na stronÄ™: {url}"

    async def wait_for_element(self, selector: str, timeout: int = 10) -> str:
        """Czeka, aÅ¼ element pojawi siÄ™ na stronie."""
        print(f"--- NarzÄ™dzie: Czekam na element '{selector}' (max {timeout}s)... ---")
        try:
            await self.page.locator(selector).wait_for(state='visible', timeout=timeout * 1000)
            return f"Element '{selector}' jest widoczny."
        except Exception as e:
            return f"BÅÄ„D: Element '{selector}' nie pojawiÅ‚ siÄ™ w ciÄ…gu {timeout}s."

    async def click_element(self, selector: str) -> str:
        """Klika na element na stronie uÅ¼ywajÄ…c selektora CSS."""
        print(f"--- NarzÄ™dzie: Klikam w element '{selector}' ---")
        try:
            await self.page.locator(selector).click(timeout=5000)
            return f"PomyÅ›lnie klikniÄ™to w element '{selector}'."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element '{selector}'. PowÃ³d: {str(e)}"

    async def click_element_in_iframe(self, iframe_selector: str, element_selector: str) -> str:
        """Klika w element, ktÃ³ry znajduje siÄ™ wewnÄ…trz ramki iframe."""
        print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by kliknÄ…Ä‡ w '{element_selector}'... ---")
        try:
            await self.page.frame_locator(iframe_selector).locator(element_selector).click(timeout=5000)
            return f"PomyÅ›lnie klikniÄ™to w element '{element_selector}' w ramce."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ kliknÄ…Ä‡ w element w ramce. PowÃ³d: {str(e)}"
    
    async def fill_input(self, selector: str, text: str) -> str:
        """WypeÅ‚nia pole tekstowe na stronie."""
        print(f"--- NarzÄ™dzie: WypeÅ‚niam pole '{selector}' tekstem '{text}' ---")
        await self.page.fill(selector, text)
        return f"PomyÅ›lnie wypeÅ‚niono pole '{selector}'."

    async def fill_input_in_iframe(self, iframe_selector: str, element_selector: str, text: str) -> str:
        """WypeÅ‚nia pole tekstowe, ktÃ³re znajduje siÄ™ wewnÄ…trz ramki iframe."""
        print(f"--- NarzÄ™dzie: Szukam ramki '{iframe_selector}', by wypeÅ‚niÄ‡ pole '{element_selector}'... ---")
        try:
            await self.page.frame_locator(iframe_selector).locator(element_selector).fill(text)
            return f"PomyÅ›lnie wypeÅ‚niono pole '{element_selector}' w ramce."
        except Exception as e:
            return f"BÅÄ„D: Nie udaÅ‚o siÄ™ wypeÅ‚niÄ‡ pola w ramce. PowÃ³d: {str(e)}"

    async def execute_javascript(self, script: str) -> str:
        """Wykonuje dowolny kod JavaScript na stronie i zwraca wynik."""
        print(f"--- NarzÄ™dzie: WykonujÄ™ skrypt JS: '{script[:50]}...' ---")
        try:
            result = await self.page.evaluate(script)
            return f"PomyÅ›lnie wykonano skrypt JS. ZwrÃ³cony wynik: {json.dumps(result)}"
        except Exception as e:
            return f"BÅÄ„D: Wykonanie skryptu JS nie powiodÅ‚o siÄ™. PowÃ³d: {str(e)}"
    
    # ... i wszystkie pozostaÅ‚e narzÄ™dzia: get_content, save_text_to_file, download_file_from_sandbox, get_page_html, list_interactive_elements ...
    async def get_content(self) -> str:
        """Pobiera i zwraca caÅ‚Ä… treÅ›Ä‡ tekstowÄ… aktualnej strony."""
        print("--- NarzÄ™dzie: Pobieram treÅ›Ä‡ strony... ---")
        content_html = await self.page.content()
        await self.sandbox.filesystem.write("/tmp/page.html", content_html)
        script = """
from bs4 import BeautifulSoup
with open('/tmp/page.html', 'r', encoding='utf-8') as f:
    soup = BeautifulSoup(f, 'html.parser')
    for item in soup(["script", "style"]): item.extract()
    print(soup.get_text(separator=' ', strip=True))
"""
        proc = await self.sandbox.process.start_and_wait(f"python -c \"{script}\"")
        return f"Oto treÅ›Ä‡ strony: {proc.stdout}"

    async def save_text_to_file(self, filename: str, content: str) -> str:
        """Zapisuje podany tekst (content) do pliku o podanej nazwie (filename)."""
        print(f"--- NarzÄ™dzie: ZapisujÄ™ dane do pliku '{filename}'... ---")
        await self.sandbox.filesystem.write(filename, content)
        return f"PomyÅ›lnie zapisano dane w pliku '{filename}'."

    async def download_file_from_sandbox(self, filename: str) -> str:
        """Pobiera plik o podanej nazwie (filename) z sandboksu na dysk lokalny."""
        print(f"--- NarzÄ™dzie: Pobieram plik '{filename}'... ---")
        file_content_bytes = await self.sandbox.filesystem.read_bytes(filename)
        with open(filename, "wb") as f: f.write(file_content_bytes)
        return f"PomyÅ›lnie pobrano plik '{filename}'."

    async def get_page_html(self) -> str:
        """Zwraca peÅ‚ny kod HTML aktualnie otwartej strony."""
        print("--- NarzÄ™dzie: Pobieram peÅ‚ny kod HTML strony... ---")
        return await self.page.content()

    async def list_interactive_elements(self) -> str:
        """Zwraca listÄ™ wszystkich interaktywnych elementÃ³w (linkÃ³w i przyciskÃ³w)."""
        print("--- NarzÄ™dzie: ListujÄ™ wszystkie interaktywne elementy... ---")
        elements = await self.page.eval_on_selector_all("a, button", """
            (elements) => elements.filter(el => el.innerText.trim()).map(el => ({
                tag: el.tagName.toLowerCase(),
                text: el.innerText.trim(),
                selector: el.getAttribute('href') ? `a[href="${el.getAttribute('href')}"]` : `#${el.getAttribute('id')}`
            }))
        """)
        unique_elements = [dict(t) for t in {tuple(d.items()) for d in elements}]
        return f"Oto znalezione elementy interaktywne: {json.dumps(unique_elements, indent=2)}"


# PÄ™tla ReAct zintegrowana z Langfuse
async def run_react_loop(agent: Agent, initial_prompt: str, trace):
    max_iterations = 15
    prompt = initial_prompt
    
    # LANGFUSE: Tworzymy "span", czyli konkretnÄ… operacjÄ™ wewnÄ…trz naszego Å›ladu (trace)
    # BÄ™dziemy w nim zapisywaÄ‡ postÄ™py i ewentualne bÅ‚Ä™dy.
    with trace.span(name="react-loop") as span:
        for i in range(max_iterations):
            span.log(name="iteration", input={"iteration": i+1, "prompt_length": len(prompt)})
            print(f"\n--- ğŸ¤” ITERACJA {i + 1}/{max_iterations} ---")
            
            try:
                # LANGFUSE: Inicjalizujemy CallbackHandlera dla tego konkretnego kroku
                # To sprawi, Å¼e wywoÅ‚anie LLM zostanie automatycznie zalogowane w Langfuse
                # i powiÄ…zane z naszym Å›ladem (trace).
                handler = CallbackHandler(trace_id=trace.id)
                agent.planner.callbacks = [handler]

                response_json = await agent.planner.get_plan(prompt)
                
                thought = response_json.get("thought")
                action_name = response_json.get("action")
                action_params = response_json.get("params", {})
                
                print(f"ğŸ’¬ MyÅ›l: {thought}")
                print(f"ğŸ¬ DziaÅ‚anie: {action_name} z parametrami {action_params}")
                
                # Logujemy myÅ›l i akcjÄ™ do Langfuse
                span.log(name="step", input={"thought": thought, "action": action_name, "params": action_params})
                
                if action_name == "finish":
                    print("\n--- âœ… ZADANIE ZAKOÅƒCZONE ---")
                    final_answer = action_params.get('answer', 'Brak odpowiedzi.')
                    print(f"Ostateczna odpowiedÅº: {final_answer}")
                    span.end(output=final_answer) # KoÅ„czymy span z wynikiem
                    return

                tool_to_execute = next((t for t in agent.tools if t.__name__ == action_name), None)
                
                if tool_to_execute:
                    observation = await tool_to_execute(**action_params)
                else:
                    observation = f"BÅÄ„D: Nie znaleziono narzÄ™dzia o nazwie '{action_name}'."
                    
                print(f"ğŸ‘€ Obserwacja: {observation[:300]}...")
                span.log(name="observation", output=observation)
                
                prompt += f"\nThought: {thought}\nAction: {json.dumps({'action': action_name, 'params': action_params})}\nObservation: {observation}"

            except Exception as e:
                print(f"BÅÄ„D KRYTYCZNY W PÄ˜TLI: {e}")
                # LANGFUSE: JeÅ›li wystÄ…pi bÅ‚Ä…d, oznaczamy span jako bÅ‚Ä™dny i zapisujemy szczegÃ³Å‚y
                error_details = traceback.format_exc()
                span.update(level='ERROR', status_message=str(e), output={"error": error_details})
                trace.update(level='ERROR')
                
                observation = f"WystÄ…piÅ‚ bÅ‚Ä…d krytyczny w pÄ™tli. SprÃ³buj inaczej. BÅ‚Ä…d: {e}"
                prompt += f"\nObservation: {observation}"
                
        print("\n--- OsiÄ…gniÄ™to limit iteracji ---")
        span.end(output={"status": "Max iterations reached"})


async def main():
    # LANGFUSE: Inicjalizacja klienta
    langfuse = Langfuse(
        public_key=LANGFUSE_PUBLIC_KEY,
        secret_key=LANGFUSE_SECRET_KEY,
        host="https://cloud.langfuse.com"
    )
    
    # LANGFUSE: Tworzymy gÅ‚Ã³wny Å›lad (trace) dla caÅ‚ego zadania
    trace = langfuse.trace(
        name="agent-scraper-run",
        tags=["development", "scraper-v1"]
    )

    browser_session = SandboxedBrowser()
    try:
        await browser_session.start()
        
        agent = Agent(
            name="AgentNadzorowany",
            description="Super-zaawansowany agent do web scrapingu, w peÅ‚ni monitorowany przez Langfuse.",
            model="gpt-4-turbo",
            tools=[
                # ... tutaj peÅ‚na lista narzÄ™dzi z browser_session ...
                 browser_session.navigate, browser_session.wait_for_element,
                browser_session.click_element, browser_session.click_element_in_iframe,
                browser_session.fill_input, browser_session.fill_input_in_iframe,
                browser_session.execute_javascript, browser_session.get_content, 
                browser_session.save_text_to_file, browser_session.download_file_from_sandbox,
                browser_session.get_page_html, browser_session.list_interactive_elements
            ],
            api_key=OPENAI_API_KEY
        )
        
        zadanie = "WejdÅº na stronÄ™ 'http://quotes.toscrape.com/'. ZnajdÅº cytat zawierajÄ…cy sÅ‚owo 'world', zapisz go w pliku 'world_quote.txt' i pobierz ten plik. Na koniec zakoÅ„cz zadanie."
        trace.update(input=zadanie) # LANGFUSE: Zapisujemy poczÄ…tkowe zadanie
        
        print(f"\n--- Zlecenie dla Agenta: {zadanie} ---\n")
        
        await run_react_loop(agent, zadanie, trace)

    except Exception as e:
        print(f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d gÅ‚Ã³wny: {e}")
        # LANGFUSE: JeÅ›li caÅ‚y proces siÄ™ wywali, oznaczamy Å›lad jako bÅ‚Ä™dny
        trace.update(level='ERROR', status_message=str(e), output={"error": traceback.format_exc()})
    finally:
        await browser_session.close()
        langfuse.flush() # LANGFUSE: Upewniamy siÄ™, Å¼e wszystkie dane zostaÅ‚y wysÅ‚ane
        print("--- ZakoÅ„czono dziaÅ‚anie. Dane wysÅ‚ano do Langfuse. ---")


if __name__ == "__main__":
    if not all([OPENAI_API_KEY, E2B_API_KEY, LANGFUSE_PUBLIC_KEY, LANGFUSE_SECRET_KEY]):
        print("BÅÄ„D: Brak jednego lub wiÄ™cej kluczy API (OpenAI, E2B, Langfuse). Ustaw je jako zmienne Å›rodowiskowe!")
    else:
        asyncio.run(main())
Krok 9.4: Analiza Danych w Panelu Langfuse
Po uruchomieniu skryptu (python scraper_agent.py), przejdÅº do swojego projektu w panelu Langfuse. Zobaczysz tam magiÄ™.

GÅ‚Ã³wny Widok: Zobaczysz nowÄ… pozycjÄ™ na liÅ›cie â€“ to TwÃ³j trace o nazwie "agent-scraper-run". JeÅ›li zadanie siÄ™ udaÅ‚o, bÄ™dzie zielony. JeÅ›li wystÄ…piÅ‚ bÅ‚Ä…d, ktÃ³ry obsÅ‚uÅ¼yliÅ›my, bÄ™dzie oznaczony na czerwono.

SzczegÃ³Å‚y Åšladu (Trace Details): Kliknij w tÄ™ pozycjÄ™. Zobaczysz peÅ‚en obraz operacji:

Metadane: Po lewej stronie zobaczysz tagi, koszt caÅ‚ego zadania, czas trwania.
OÅ› Czasu (Timeline): Zobaczysz gÅ‚Ã³wny span o nazwie "react-loop". WewnÄ…trz niego, jak w drzewie, bÄ™dÄ… zagnieÅ¼dÅ¼one wszystkie operacje.
Spany LLM: KaÅ¼de wywoÅ‚anie agent.planner.get_plan pojawi siÄ™ jako osobny, zagnieÅ¼dÅ¼ony element. KlikajÄ…c w niego, zobaczysz:
Input: DokÅ‚adny, peÅ‚ny prompt, ktÃ³ry zostaÅ‚ wysÅ‚any do GPT-4.
Output: Surowa odpowiedÅº JSON od modelu.
Usage & Cost: Liczba tokenÃ³w i precyzyjny koszt tego jednego zapytania.
Logi: WewnÄ…trz spana "react-loop" zobaczysz logi, ktÃ³re dodaliÅ›my rÄ™cznie: iteration, step z myÅ›lÄ… i akcjÄ…, oraz observation. MoÅ¼esz krok po kroku przeÅ›ledziÄ‡ caÅ‚y proces decyzyjny agenta.
Debugowanie BÅ‚Ä™du: JeÅ›li w trakcie pÄ™tli wystÄ…pi bÅ‚Ä…d, span "react-loop" i caÅ‚y trace zostanÄ… oznaczone na czerwono. W szczegÃ³Å‚ach spana znajdziesz status_message z treÅ›ciÄ… bÅ‚Ä™du oraz peÅ‚ny traceback w logach, co pozwoli Ci natychmiast zlokalizowaÄ‡ problem w kodzie.

Podsumowanie
Gratulacje! TwÃ³j agent nie jest juÅ¼ czarnÄ… skrzynkÄ…. Jest w peÅ‚ni oprzyrzÄ…dowanym, transparentnym systemem. ZyskaÅ‚eÅ› moÅ¼liwoÅ›Ä‡ nie tylko obserwacji, ale i gÅ‚Ä™bokiej analizy jego zachowania, kosztÃ³w i wydajnoÅ›ci. NauczyÅ‚eÅ› siÄ™ teÅ¼, jak profesjonalnie obsÅ‚ugiwaÄ‡ i logowaÄ‡ bÅ‚Ä™dy. To jest kamieÅ„ milowy, ktÃ³ry przenosi Twoje umiejÄ™tnoÅ›ci z tworzenia dziaÅ‚ajÄ…cych prototypÃ³w na budowanie niezawodnych i gotowych do wdroÅ¼enia aplikacji AI.